<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>b page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #playground {
            width: 100vw;
            height: 100vh;
            font-size: 16px;
            font-family:'Hiragino Sans GB','STXihei';
            color: #372d52;
        }

        .menu__column {
            position: fixed;
            display: flex;
            flex-direction: column;
            width: 200px;
            box-shadow: 
                2px 1px 1px #a7783d, 
                -1px -1px 1px #fff;
            background-color: antiquewhite;
            border-radius: 4px;
        }
        .menu__item {
            display: flex;
            margin: 2px;
            padding: 2px 6px 2px 6px;
            justify-content: space-between;
        }
        .menu__item--on-path,
        .menu__item:hover {
            border-radius: 8px;
            background-color:aliceblue;
            /* color: #fff; */
        }
        .menu__icon {
            width: 16px;
            height: 16px;
            /* color: #000; */
            font-weight: bolder;
        }
    </style>
</head>
<body>
    <div id="playground"></div>
    <script>
        let position = {
            x: 0,
            y: 0
        }
        let preDirection = {
            x: 'right',
            y: 'bottom'
        }
        let direction = new Proxy(
            {
                x: 'right',
                y: 'bottom'
            }, 
            {
                set (target, key, value) {
                    // 新旧不同时，旧值给到 preDirection
                    if (target[key] !== value) {
                        preDirection[key] = target[key]
                        target[key] = value
                    }
                }
            }
        )
        let adjustXY = {
            x: 0, 
            y: 0
        }
        // 新添加的栏，要在哪个方向上新增
        function getAppendDirection(position=position, size={ width: 200, height: 0}) {
            const { x, y } = position
            const { innerWidth, innerHeight } = window
            const { width, height } = size
            if (x + width > innerWidth) { direction.x = 'left' }
            if (y + height > innerHeight) { direction.y = 'top'}
            if (x - width < 0) { direction.x = 'right'}
            if (y - height < 0) { direction.y = 'bottom'}
            const directionstr = `${preDirection.x}-${preDirection.y}` // 惰性更改方向...但是有个问题，我 tmd 之前拿 preDirection 在干嘛...
            return directionstr
        }
        function operateAdjustXY(adjustXY, direction) {
            switch (direction) {
                case 'right-bottom':
                    adjustXY.x = 190
                    adjustXY.y = 21
                    break
                case 'left-bottom':
                    adjustXY.x = -190
                    adjustXY.y = 21
                    break
                case 'right-top':
                    adjustXY.x = 190
                    adjustXY.y = -21
                    break
                case 'left-top':
                    adjustXY.x = -190
                    adjustXY.y = -21
                    break
                default:
                    break
            }
        }

        /**
         * 嗯...不对，应该首先考虑，有两种东西。一个是，一个栏，一个是，一个栏里面的条目
         * 可监听的事件就是移入移出。并且我们有这些文本的类似 parent-child 的关系
         * 我们的 hover 事件，肯定是要精准到条目的
         * 进而，继续理
         * 
         * 当 hover 到一个条目时，如果有子元素，就渲染子元素，没有的话...就不渲染这不废话...
         * 当 hover 离开一个条目时...
         * 
         * 细分。先看 a，状态以及可能的转移
         * a.1 
         * 当前没有 hover 到任何条目上位于空白，将要 hover 到某个条目
         * a.2
         * 当前 hover 到了某一个条目，将要离开这个条目
         * a.2.1
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了其子元素
         * a.2.2
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了其父元素
         * a.2.3
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了空白
         * a.2.4
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了兄弟元素
         * 
         * 然后是处理办法
         * b.1
         * hover 到某个条目，高亮，若数据结构里有子元素，渲染其子元素
         * b.2.1
         * hover 离开某个条目，高亮消失，进入其子元素，高亮，重复 a.2
         * b.2.2
         * hover 离开某个条目，高亮消失，进入其父一级的栏，取消本层的渲染，重复 a.2
         * b.2.3
         * hover 离开某个条目，进入空白，高亮消失，不做处理
         * b.2.4
         * hover 离开某个条目，进入兄弟元素，高亮消失，若此时本条目子元素已渲染，取消渲染，重复 a.2
         * 
         * 如何更合理的处理这个问题？
         * 
         * 如何判断是进入了子元素，还是父元素，还是兄弟元素，还是空白？
         * 每当进入某一层的时候，记录层数，这是一个全局变量，维护表示的是当前层数。
         * 而每一个栏，都有固定的一个数字。
         * 对于空白，给-1.
         * 
         * 每一次"进入"，都会改变这个层数，同时也可以计算出一个差值，这个差值，有可能是0，1，-1.甚至更大一些的数字。
         * 但是无所谓，我觉得有正负和零就够了。原来...这就是进入
         * 那"离开"是什么？
         * 也许根本就不需要有离开这个概念，只需要有进入这个概念就够了。
         * 
         * wow...这个思路真棒
         * 而且数据命名如果规范的话，一切都可以很方便
         * const getStep = (string1,string2) => string1.length - string2.length
         * 
         * 然后也许需要看看树的遍历，一个是看现在渲染了多少是什么状态，又进行了什么操作，以及下一步要做什么
         * 整个过程...也许可以更依赖数据结构一点
         */

        /**
         * 嗯，上面的初步实现了，也重新改了 ui，bug还有但是不想管了
         * 后续优化可能会有，如何把路径高亮加回去，还有新增 item 方向...还有代码写的一坨一坨
         * 
         * 
         */

        let layer = -1
        function renderOneLayer (name='0', root=playground) {
            const thisPosition = position
            const selfData = getNode(name, article) || article[0]

            if (!selfData) return
            if (!selfData.children) return
            const selfEle = document.createElement('div')
            selfEle.innerHTML = `
                <div class="menu__column" data-name="${name}" style="left: ${thisPosition.x}px;top: ${thisPosition.y}px;">
                    ${selfData.children.map(child => `<div class="menu__item" data-name=${child.name}>${child.content + (child.children ? '<div class="menu__icon">></div>' : '')}</div>`).join('')}
                </div>
            `
            root.appendChild(selfEle)
            selfEle.animate([
                { 
                    opacity: 0,
                    transform: 'translateY(-20px)'
                },
                { 
                    opacity: 1,
                    transform: 'translateY(0px)'
                }
            ], {
                duration: 200,
                easing: 'ease-in-out'
            })
            const items = selfEle.querySelectorAll('.menu__item')
            
            // get next position
            operateAdjustXY(adjustXY, getAppendDirection(thisPosition, { width: 200, height: 0 }))

            items.forEach((item, index) => {
                const name = item.getAttribute('data-name')
                const data = getNode(name, article)

                // layer 这个变量什么时候更新合适？
                item.addEventListener('mouseenter', function (e) {
                    let thisLayer =  e.target.getAttribute('data-name').length
                    position.x = item.getBoundingClientRect().left + adjustXY.x
                    position.y = item.getBoundingClientRect().top + adjustXY.y

                    if(layer - thisLayer === 0) {
                        const siblings = getSiblings(e.target.getAttribute('data-name'), article).filter(sibling => sibling.name !== e.target.getAttribute('data-name'))
                        const children = siblings.map(sibling => getChildren(sibling.name, article)).flat()
                        siblings.concat(children).forEach(child => {
                            const columnEles = document.querySelectorAll('.menu__column')
                            const childEle = [...columnEles].find(ele => ele.getAttribute('data-name') === child.name)
                            if (childEle) childEle.remove()
                        })
                    }
                    if(layer - thisLayer > 0) {
                        const children = getChildren(e.target.getAttribute('data-name'), article)
                        children.forEach(child => {
                            const columnEles = document.querySelectorAll('.menu__column')
                            const childEle = [...columnEles].find(ele => ele.getAttribute('data-name') === child.name)
                            if (childEle) childEle.remove()
                        })
                    }
                    if(layer - thisLayer < 0) {
                    }
                    if(data.children) renderOneLayer(e.target.getAttribute('data-name'))
                    layer = thisLayer
                })
            })  
        }

        function getNode (name, article) {
            let node = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    node = article[i]
                    break
                } else if (article[i].children) {
                    node = getNode(name, article[i].children)
                    if (node) {
                        break
                    }
                }
            }
            return node
        }
        function getSiblings(name,article) {
            let siblings = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    siblings = article // this is the only difference between getSiblings and getNode...?
                    break
                } else if (article[i].children) {
                    siblings = getSiblings(name, article[i].children)
                    if (siblings) {
                        break
                    }
                }
            }
            return siblings
        }

        function getChildren(name,article) {
            let children = []
            getNode(name, article)?.children?.forEach(child => {
                children.push(child)
                if (child.children) {
                    children = children.concat(getChildren(child.name, article))
                }
            })
            return children
        }

        const playground = document.getElementById('playground')
        const background = document.getElementById('background')
        const article = [
            {
                name:'',
                content:'0',
                children:[
                    {
                        name:'a',
                        content: '内库烧为锦绣灰，',
                        children: [
                            {
                                name: 'aa',
                                content: '天街踏尽公卿骨。',
                                children: [
                                    {
                                        name: 'aaa',
                                        content: '待到秋来九月八'
                                    },
                                    {
                                        name: 'aab',
                                        content: '我花开后百花杀'
                                    },
                                    {
                                        name: 'aac',
                                        content: '冲天香阵透长安',
                                    },
                                    {
                                        name: 'aad',
                                        content: '满城尽带黄金甲',
                                        children: [
                                            {
                                                name: 'aada',
                                                content: '红旗卷起农奴戟',
                                                children: [
                                                    {
                                                        name: 'aadaa',
                                                        content: '黑手高悬霸主鞭',
                                                        children: [
                                                            {
                                                                name: 'aadaaa',
                                                                content: '为有牺牲多壮志',
                                                                children: [
                                                                    {
                                                                        name: 'aadaaaa',
                                                                        content: '敢教日月换新天'
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                name: 'ab',
                                content: '陈王昔时宴平乐',
                                children: [
                                    {
                                        name: 'aba',
                                        content: '陈王奋起挥黄钺',
                                        children: [
                                            {
                                                name: 'abaa',
                                                content: '阿巴阿巴'
                                            }
                                        ]
                                    },
                                    {
                                        name: 'abb',
                                        content: '阿巴巴'
                                    }
                                ]
                            },
                            {
                                name: 'ac',
                                content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试'
                            },
                            {
                                name: 'ad',
                                content: '测试测试测'
                            },
                            {
                                name: 'ae',
                                content: '测试测试测'
                            }
                        ]
                    }
                ]
            }
        ]
        function init() {
            const start = document.createElement('div')
            start.innerHTML = `
                <div class="menu__column" data-name="start00000000" style="left: 0px;top: 0px;">
                    <div class="menu__item" data-name="0">Start~<div class="menu__icon">></div></div>
                </div>
            `
            start.addEventListener('click',(e)=>{
                position.x = 200
                position.y = 21
                renderOneLayer('0')
            })
            playground.appendChild(start)
            document.addEventListener('click', (e) => {
                if(e.target === playground){
                    document.querySelectorAll('.menu__column').forEach(ele => {
                        if(ele.getAttribute('data-name') !== 'start00000000') {
                            ele.remove()
                        }
                    })
                }
            })
        
        }
        init()

        /**
         * 也许...我不应该这么丧...
         * 也许...我现在确实无聊又窘迫..
         * 我应该做什么？
         * 
         * 去学习痛苦吗...
         * 学校，父母...也只是那样...一开始是哄骗试探，慢慢威胁恐吓，最后是解离一般将自己看作个干脏活的...
         * 那些东西都太...
         * 如何原谅别人？去变强就好了，人不会向着一个被踩死的蚂蚁去寻求原谅，蚂蚁也没资格去原谅别人，这么干的有一个算一个都是神经病，但是如果踩的是老虎尾巴那就有寻求原谅的必要了。所以，去变强，纯粹的变强，这样就可以原谅了。“告诉我，我拿什么原谅你？我有什么资格原谅你？我有什么手段能把你也弄得半死不活？”
         * 
         * 学习痛苦与耻辱...
         * 像新生的婴儿那样...
         * 像...小时候那样...
         * 
         * 我一遍遍问的，究竟什么才算是值得的，我到底应该干什么？
         * 中学说是好好考试就好，即使不论把精力全投进那种考试中然后今天到这样算不算值得，
         * 中学里根本就不纯粹，初中喜欢捞便宜占搞补课班的班主任，高中因为我留头发一直吵，
         * 里面夹杂了太多乱七八糟的事，父母的懦弱、大惊小怪，学校以及所谓的“社会”的恐吓，
         * 就算我想当机器也当不好。
         * 所以，告诉我，这一切都是为了什么？
         * 
         * 到现在学历没再那么万能，就行它本来就屁用没有一样，
         * 想要的东西，尊重也好力量也好，哪怕是知识，学历都换不来，背书、等待也换不来...
         * 也许...我不应该这么丧...痛苦会在...仇恨会在...
         * 它们是生出你的东西，只是不要...把它们当作，全部。
         * 
         * 我是小狗吗？
         * 我是笨蛋吗
         * 我应该，去做点什么，
         * 就算，我只是，来旅游的。
         */
    </script>
</body>
</html>