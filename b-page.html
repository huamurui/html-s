<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>b page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #playground {
            width: 100vw;
            height: 100vh;
            font-size: 16px;
        }

        .menu__column {
            position: fixed;
            display: flex;
            flex-direction: column;
            width: 200px;
            box-shadow: 
                2px 1px 1px #666, 
                -1px -1px 1px #fff;
            background-color: antiquewhite;
        }
        .menu__item {
            width: 100%;
        }
        .menu__icon {
            width: 16px;
            height: 16px;
            color: #000;
            font-weight: bolder;
        }
    </style>
</head>
<body>
    <div id="playground"></div>
    <script>
        // 我想整个东西，就是，根据 hover 来动态的，展开一颗树。UI 风格的话，最好，像古早 windows 的开始菜单那样
        // 如果那样搞，定位是个问题... 绝对定位 or translate 那一套就好。获取窗口宽高，与最后一个元素的定位
        // 还有一件事... 这玩意要在移动端看... 以及冻结状态... 移动端是随时冻结。PC 听一下双击事件，或者是长按事件 bulabula
        /*
            本以为叠压关系不会是问题...但现在来看...是问题。
            原本我是直接在 html 结构上复制了数据结构，这样其实很巧妙的解决了 mouseenter mouseleave 。但，也因为这样，导致了叠压关系的问题。因为嵌套结构，最后一个渲染的元素并不一定会被贴在最上层。
            并且原来的 mouseenter mouseleave 在我写 margin 的那时候也是有缺陷的，在同一级切换 hover 时，会有闪屏。
            还有一件事，怎么判断是不是叶子，就看有没有 children

            所以...也许，应该使用不嵌套的渲染。这样叠压会不需要多处理，而 mouseenter mouseleave... 有没有合理一些的？
            也许我会希望，退出是有层级的，除非是点击事件直接全部清空，如果是 hover，都是先进入再退出。
            好，重新叙述一遍。

            渲染了一个元素，加了 mouseenter mouseleave 两个事件，mouseenter 时，渲染子元素，mouseleave 时有两种情况，一种是为了进入子元素，一种是直接退出。
            如果是为了进入子元素，那么就不用处理，如果是直接退出，那么就要清空子元素与当前这层的元素。那好了，怎么判断这两种情况。
            很妙哦~我甚至感觉有点明白为什么那个 UI 要压住一点了，离开的方向很重要，如果是从右边那么就有可能是为了进入子元素，如果是其他三面，那么就是直接退出。
        */
        let position = {
            x: 0,
            y: 0
        }

        function getDirection(position=position, size={ width: 200, height: 0}, window=window) {
            const { x, y } = position
            const { innerWidth, innerHeight } = window
            const { width, height } = size
            const direction = {x: 'right', y: 'bottom'}
            if (x + width > innerWidth) { direction.x = 'left' }
            if (y + height > innerHeight) { direction.y = 'top'}
            return direction
        }
        const { innerWidth, innerHeight } = window
        function renderOneLayer (name='a', root=playground) {
            const thisPosition = position

            const parentEle = root.querySelector(`[data-name="${name}"]`) || root
            const selfData = getNode(name, article)

            // render self
            const selfEle = document.createElement('div')

            selfEle.style = `
                left: ${thisPosition.x}px;
                top: ${thisPosition.y}px;
            `
            selfEle.classList.add('menu__column')
            
            selfEle.setAttribute('data-name', name)
            // menu__item 意味着这是个叶子节点...但这里其实又不一定... 所以...可能没什么意义。
            selfEle.innerHTML = `<div class="menu__item"><span class="menu__icon">~</span>${selfData.content}</div>`
            parentEle.appendChild(selfEle)
            console.log(name,thisPosition)

            if (selfData.children) {
                // render children when hover
                selfEle.addEventListener('mouseenter', function () {  
                    position.x += 190
                    position.y += 21 // 先固定加上一个高度...

                    let accumulateHeight = 0
                    selfData.children.forEach(child => {
                        renderOneLayer(child.name, selfEle)
                        let thisHeight = selfEle.querySelector(`[data-name="${child.name}"]`).getBoundingClientRect().height
                        position.y += thisHeight
                        accumulateHeight += thisHeight
                    })
                    position.y -= accumulateHeight
                })

                // remove children when leave
                selfEle.addEventListener('mouseleave', function () {
                    position.x -= 190
                    position.y -= 21
                    selfData.children.forEach(child => {
                        // position.y -= selfEle.querySelector(`[data-name="${child.name}"]`).getBoundingClientRect().height
                        const childEle = selfEle.querySelector(`[data-name="${child.name}"]`)
                        selfEle.removeChild(childEle)
                    })
                })
            }
        }

        function getNode (name, article) {
            // get node of article by name, return array. recursively, for it might hide in children's children
            let node = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    node = article[i]
                    break
                } else if (article[i].children) {
                    node = getNode(name, article[i].children)
                    if (node) {
                        break
                    }
                }
            }
            return node
        }

        const playground = document.getElementById('playground')
        const article = [
            {
                name:'a',
                content: '嗯...',
                children: [
                    {
                        name: 'aa',
                        content: '不知道说什么好...',
                        children: [
                            {
                                name: 'aab',
                                content: '如果已经不怎么在乎...如果路只会越走越窄...'
                            },
                            {
                                name: 'aac',
                                content: '什么十几年的努力...其实从一开始就，那么的，那么那么的，虚浮...，空中楼阁一般'
                            }
                        ]
                    },
                    {
                        name: 'ab',
                        content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试',
                        children: [
                            {
                                name: 'aba',
                                content: '阿巴阿',
                                children: [
                                    {
                                        name: 'abaa',
                                        content: '阿巴阿巴'
                                    }
                                ]
                            },
                            {
                                name: 'abb',
                                content: '阿巴巴'
                            }
                        ]
                    },
                    {
                        name: 'ac',
                        content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试'
                    }
                ]
            }
        ]
        renderOneLayer()
    </script>
</body>
</html>