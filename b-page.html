<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>b page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #playground {
            width: 100vw;
            height: 100vh;
            font-size: 16px;
        }

        .menu__column {
            position: fixed;
            display: flex;
            flex-direction: column;
            width: 200px;
            box-shadow: 
                2px 1px 1px #666, 
                -1px -1px 1px #fff;
            background-color: antiquewhite;
        }
        .menu__item {
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
        .menu__item--on-path {
            background-color: #666;
            color: #000;
        }
        .menu__item:hover {
            background-color:#000;
            color: #fff;
        }
        .menu__icon {
            width: 16px;
            height: 16px;
            color: #000;
            font-weight: bolder;
        }
    </style>
</head>
<body>
    <div id="playground"></div>
    <script>
        // 我想整个东西，就是，根据 hover 来动态的，展开一颗树。UI 风格的话，最好，像古早 windows 的开始菜单那样
        // 如果那样搞，定位是个问题... 绝对定位 or translate 那一套就好。获取窗口宽高，与最后一个元素的定位
        // 还有一件事... 这玩意要在移动端看... 以及冻结状态... 移动端是随时冻结。PC 听一下双击事件，或者是长按事件 bulabula
        /*
            本以为叠压关系不会是问题...但现在来看...是问题。
            原本我是直接在 html 结构上复制了数据结构，这样其实很巧妙的解决了 mouseenter mouseleave 。但，也因为这样，导致了叠压关系的问题。因为嵌套结构，最后一个渲染的元素并不一定会被贴在最上层。
            并且原来的 mouseenter mouseleave 在我写 margin 的那时候也是有缺陷的，在同一级切换 hover 时，会有闪屏。
            还有一件事，怎么判断是不是叶子，就看有没有 children

            所以...也许，应该使用不嵌套的渲染。这样叠压会不需要多处理，而 mouseenter mouseleave... 有没有合理一些的？
            也许我会希望，退出是有层级的，除非是点击事件直接全部清空，如果是 hover，都是先进入再退出。
            好，重新叙述一遍。

            渲染了一个元素，加了 mouseenter mouseleave 两个事件，mouseenter 时，渲染子元素，mouseleave 时有两种情况，一种是为了进入子元素，一种是直接退出。
            如果是为了进入子元素，那么就不用处理，如果是直接退出，那么就要清空子元素与当前这层的元素。那好了，怎么判断这两种情况。
            很妙哦~我甚至感觉有点明白为什么那个 UI 要压住一点了，离开的方向很重要，如果是从右边那么就有可能是为了进入子元素，如果是其他三面，那么就是直接退出。

            弄了半天还是一个有 bug 的版本...
            还有一件事，新增元素的方向改变，其实应该是惰性的，而不应该有那种...次次刷新的初始值，我是说那样，从左铺到右，从右铺到左，从左铺到右，从右铺到左...。也没啥，就是这样铺的比较满。

            阿巴阿巴...巨大的，空虚感。
            那怎么办呢。
        */
        let position = {
            x: 0,
            y: 0
        }
        let direction = {
            x: 'right',
            y: 'bottom'
        }
        // 新添加的栏，要在哪个方向上新增
        function getAppendDirection(position=position, size={ width: 200, height: 0}) {
            const { x, y } = position
            const { innerWidth, innerHeight } = window
            const { width, height } = size
            if (x + width + 190 > innerWidth) { direction.x = 'left' } //...因为 position 目前是定位在左上角的，所以这里要加上一个宽高
            if (y + height + 21 > innerHeight) { direction.y = 'top'}
            if (x - 190 < 0) { direction.x = 'right'}
            if (y - 21 < 0) { direction.y = 'bottom'}
            const directionstr = `${direction.x}-${direction.y}`
            return directionstr
        }
        // 鼠标移出一个栏时，是从哪个方向移出的
        function getLeaveDirection(e, el) {
            const { clientX, clientY } = e
            const { x, y, width, height } = el.getBoundingClientRect()
            let direction = ''
            switch (true) {
                case clientY < y:
                    direction = 'top'
                    break
                case clientY > y + height:
                    direction = 'bottom'
                    break
                case clientX < x:
                    direction = 'left'
                    break
                case clientX > x + width-5:
                    direction = 'right'
                    break
                default:
                    break
            }
            return direction
        }

        // 如果是，还是给一个 name，但渲染的不是本元素，而是子元素？
        function renderOneLayer (name='0', root=playground) {
            const thisPosition = position
            const selfData = getNode(name, article)

            if (!selfData) return
            if (!selfData.children) return
            // render self
            const selfEle = document.createElement('div')
            selfEle.setAttribute('data-name', name)
            selfEle.style = `left: ${thisPosition.x}px;top: ${thisPosition.y}px;`
            selfEle.classList.add('menu__column')
            selfEle.innerHTML = selfData.children.map(child => `<div class="menu__item" data-name=${child.name}>${child.content + (child.children ? '<div class="menu__icon">+</div>' : '')}</div>`).join('')
            
            root.appendChild(selfEle)
            const items = selfEle.querySelectorAll('.menu__item')
            
            // get position
            let adjustXY = {x: 0, y: 0}
            switch (getAppendDirection(thisPosition, selfEle.getBoundingClientRect())) {
                case 'right-bottom':
                    adjustXY.x = 190
                    adjustXY.y = 21
                    break
                case 'left-bottom':
                    adjustXY.x = -190
                    adjustXY.y = 21
                    break
                case 'right-top':
                    adjustXY.x = 190
                    adjustXY.y = -21
                    break
                case 'left-top':
                    adjustXY.x = -190
                    adjustXY.y = -21
                    break
                default:
                    break
            }
            // 这一层里面只能有一条
            let plannedParenthood = false
            // recursively
            items.forEach((item, index) => {
                const name = item.getAttribute('data-name')
                const data = getNode(name, article)
                if(!data.children)  return
                // render children when mouseenter
                item.addEventListener('mouseenter', function () {
                    if (plannedParenthood) {
                        item.classList.remove('menu__item--on-path')
                        root.querySelector(`[data-name="${plannedParenthood}"].menu__column`) && root.removeChild(root.querySelector(`[data-name="${plannedParenthood}"].menu__column`)) && (position.x -= adjustXY.x, position.y -= adjustXY.y)
                        plannedParenthood = false
                        // debugger
                    }
                    position.x += adjustXY.x
                    position.y += adjustXY.y
                    item.classList.add('menu__item--on-path')
                    renderOneLayer(name, root)
                    plannedParenthood = name

                })
                // remove children when mouseleave
                item.addEventListener('mouseleave', function () {
                    let dir = getLeaveDirection(event, selfEle)
                    // bug... 从右边离开时，不去掉子元素，而...这时如果又触发了同级 mouseenter ... 那就全都乱了...再加一个变量 let plannedParenthood = false
                    // 现在的问题是，在离开父级前，就进入了之后渲染出的子表...直接跨级的交互...
                    if(dir === 'right') {
                        plannedParenthood = item.getAttribute('data-name')
                        return
                    }
                    if(!plannedParenthood) return
                    root.querySelector(`[data-name="${name}"].menu__column`) && root.removeChild(root.querySelector(`[data-name="${name}"].menu__column`)) && (position.x -= adjustXY.x, position.y -= adjustXY.y) && (plannedParenthood = false)
                })
            })
        }

        function getNode (name, article) {
            let node = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    node = article[i]
                    break
                } else if (article[i].children) {
                    node = getNode(name, article[i].children)
                    if (node) {
                        break
                    }
                }
            }
            return node
        }

        const playground = document.getElementById('playground')
        const article = [
            {
                name:'0',
                content:'0',
                children:[
                    {
                        name:'a',
                        content: '嗯...',
                        children: [
                            {
                                name: 'aa',
                                content: '不知道说什么好...',
                                children: [
                                    {
                                        name: 'aab',
                                        content: '如果已经不怎么在乎...如果路只会越走越窄...'
                                    },
                                    {
                                        name: 'aac',
                                        content: '什么十几年的努力...其实从一开始就，那么的，那么那么的，虚浮...，空中楼阁一般'
                                    }
                                ]
                            },
                            {
                                name: 'ab',
                                content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试',
                                children: [
                                    {
                                        name: 'aba',
                                        content: '阿巴阿',
                                        children: [
                                            {
                                                name: 'abaa',
                                                content: '阿巴阿巴'
                                            }
                                        ]
                                    },
                                    {
                                        name: 'abb',
                                        content: '阿巴巴'
                                    }
                                ]
                            },
                            {
                                name: 'ac',
                                content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试'
                            }
                        ]
                    }
                ]
            }
        ]
        renderOneLayer()
    </script>
</body>
</html>