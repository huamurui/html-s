<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>b page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #playground {
            width: 100vw;
            height: 100vh;
            font-size: 16px;
        }

        .menu__column {
            position: fixed;
            display: flex;
            flex-direction: column;
            width: 200px;
            box-shadow: 
                2px 1px 1px #666, 
                -1px -1px 1px #fff;
            background-color: antiquewhite;
        }
        .menu__item {
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
        .menu__item--on-path {
            background-color: #666;
            color: #000;
        }
        .menu__item:hover {
            background-color:#000;
            color: #fff;
        }
        .menu__icon {
            width: 16px;
            height: 16px;
            color: #000;
            font-weight: bolder;
        }
    </style>
</head>
<body>
    <div id="playground"></div>
    <script>

        /* 
            Cascading dropdown...
            对，这个玩意叫做级联菜单，cascade dropdown... 搓不出来就搓不出来
            ant design 的做的就不错。只不过... 他们的源码层层叠叠整个系统共用也有很多工具... 
            有空看看他们是怎么处理我这边踩的一堆坑的吧...

            原来只需要计划生育就可以了啊...不用管什么进出方向的...
            plannedParenthood
            或者看看别的，是，怎么实现的，联级...嗯，那个组件库作者曾经搞得那个介绍树形结构的 ppt
            多余的思考可以先丢掉了。反正也只是跟着学着实现功能
        */
        let position = {
            x: 0,
            y: 0
        }
        let preDirection = {
            x: 'right',
            y: 'bottom'
        }
        let direction = new Proxy(
            {
                x: 'right',
                y: 'bottom'
            }, 
            {
                set (target, key, value) {
                    // 新旧不同时，旧值给到 preDirection
                    if (target[key] !== value) {
                        preDirection[key] = target[key]
                        target[key] = value
                    }
                }
            }
        )
        let adjustXY = {
            x: 0, 
            y: 0
        }
        // 新添加的栏，要在哪个方向上新增
        function getAppendDirection(position=position, size={ width: 200, height: 0}) {
            const { x, y } = position
            const { innerWidth, innerHeight } = window
            const { width, height } = size
            if (x + width > innerWidth) { direction.x = 'left' }
            if (y + height > innerHeight) { direction.y = 'top'}
            if (x - width < 0) { direction.x = 'right'}
            if (y - height < 0) { direction.y = 'bottom'}
            const directionstr = `${direction.x}-${direction.y}`
            return directionstr
        }
        function operateAdjustXY(adjustXY, direction) {
            switch (direction) {
                case 'right-bottom':
                    adjustXY.x = 190
                    adjustXY.y = 21
                    break
                case 'left-bottom':
                    adjustXY.x = -190
                    adjustXY.y = 21
                    break
                case 'right-top':
                    adjustXY.x = 190
                    adjustXY.y = -21
                    break
                case 'left-top':
                    adjustXY.x = -190
                    adjustXY.y = -21
                    break
                default:
                    break
            }
        }

        // 鼠标移出一个栏时，是从哪个方向移出的
        function getLeaveDirection(e, el) {
            const { clientX, clientY } = e
            const { x, y, width, height } = el.getBoundingClientRect()
            let direction = ''
            switch (true) {
                case clientY <= y:
                    direction = 'top'
                    break
                case clientY >= y + height:
                    direction = 'bottom'
                    break
                case clientX <= x + 5:
                    direction = 'left'
                    break
                case clientX >= x + width-5:
                    direction = 'right'
                    break
                default:
                    break
            }
            return direction
        }

        function deepClone (obj) {
            return JSON.parse(JSON.stringify(obj))
        }

        // 如果是，还是给一个 name，但渲染的不是本元素，而是子元素？
        function renderOneLayer (name='0', root=playground) {
            const thisPosition = position
            const selfData = getNode(name, article)

            if (!selfData) return
            if (!selfData.children) return
            // render self
            const selfEle = document.createElement('div')
            selfEle.setAttribute('data-name', name)
            selfEle.style = `left: ${thisPosition.x}px;top: ${thisPosition.y}px;`
            selfEle.classList.add('menu__column')
            selfEle.innerHTML = selfData.children.map(child => `<div class="menu__item" data-name=${child.name}>${child.content + (child.children ? '<div class="menu__icon">></div>' : '')}</div>`).join('')
            
            root.appendChild(selfEle)
            const items = selfEle.querySelectorAll('.menu__item')
            
            // get position
            operateAdjustXY(adjustXY, getAppendDirection(thisPosition, { width: 200, height: 0 }))

            // 这一层里面只能有一条
            let plannedParenthood = false
            // recursively
            items.forEach((item, index) => {
                const name = item.getAttribute('data-name')
                const data = getNode(name, article)
                if(!data.children)  return
                // render children when mouseover

                item.addEventListener('mouseover', function () {
                    if (plannedParenthood) {
                        item.classList.remove('menu__item--on-path')
                        root.querySelector(`[data-name="${plannedParenthood}"].menu__column`) && root.removeChild(root.querySelector(`[data-name="${plannedParenthood}"].menu__column`)) && (position.x -= adjustXY.x, position.y -= adjustXY.y)
                        plannedParenthood = false
                    }
                    position.x += adjustXY.x
                    position.y += adjustXY.y
                    item.classList.add('menu__item--on-path')
                    renderOneLayer(name, root)
                    plannedParenthood = name
                })
                // remove children when mouseleave
                item.addEventListener('mouseleave', function (event) {
                    let leaveDirection = getLeaveDirection(event, selfEle)
                    if(leaveDirection === preDirection.x) {
                        plannedParenthood = item.getAttribute('data-name')
                        operateAdjustXY(adjustXY, getAppendDirection({
                            x: thisPosition.x + adjustXY.x,
                            y: thisPosition.y + adjustXY.y
                        }, { width: 200, height: 0 }))
                        return
                    }
                    if(!plannedParenthood) return
                    root.querySelector(`[data-name="${name}"].menu__column`) && root.removeChild(root.querySelector(`[data-name="${name}"].menu__column`)) && (position.x -= adjustXY.x, position.y -= adjustXY.y) && (plannedParenthood = false)
                })

                // touch event for mobile
                item.addEventListener('touchend', function (event) {
                    event.preventDefault()
                    if (plannedParenthood) {
                        item.classList.remove('menu__item--on-path')
                        root.querySelector(`[data-name="${plannedParenthood}"].menu__column`) && root.removeChild(root.querySelector(`[data-name="${plannedParenthood}"].menu__column`)) && (position.x -= adjustXY.x, position.y -= adjustXY.y)
                        plannedParenthood = false
                    }
                    position.x += adjustXY.x
                    position.y += adjustXY.y
                    item.classList.add('menu__item--on-path')
                    renderOneLayer(name, root)
                    plannedParenthood = name
                })

            })  
        }

        function getNode (name, article) {
            let node = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    node = article[i]
                    break
                } else if (article[i].children) {
                    node = getNode(name, article[i].children)
                    if (node) {
                        break
                    }
                }
            }
            return node
        }

        const playground = document.getElementById('playground')
        const article = [
            {
                name:'0',
                content:'0',
                children:[
                    {
                        name:'a',
                        content: '嗯...',
                        children: [
                            {
                                name: 'aa',
                                content: '不知道说什么好...',
                                children: [
                                    {
                                        name: 'aab',
                                        content: '如果已经不怎么在乎...如果路只会越走越窄...'
                                    },
                                    {
                                        name: 'aac',
                                        content: '什么十几年的努力...其实从一开始就，那么的，那么那么的，虚浮...，空中楼阁一般'
                                    },
                                    {
                                        name: 'aad',
                                        content: '我想...',
                                        children: [
                                            {
                                                name: 'aada',
                                                content: '红旗卷起农奴戟',
                                                children: [
                                                    {
                                                        name: 'aadaa',
                                                        content: '黑手高悬霸主鞭',
                                                        children: [
                                                            {
                                                                name: 'aadaaa',
                                                                content: '为有牺牲多壮志',
                                                                children: [
                                                                    {
                                                                        name: 'aadaaaa',
                                                                        content: '敢教日月换新天'
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]
                                    },
                                ]
                            },
                            {
                                name: 'ab',
                                content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试',
                                children: [
                                    {
                                        name: 'aba',
                                        content: '阿巴阿',
                                        children: [
                                            {
                                                name: 'abaa',
                                                content: '阿巴阿巴'
                                            }
                                        ]
                                    },
                                    {
                                        name: 'abb',
                                        content: '阿巴巴'
                                    }
                                ]
                            },
                            {
                                name: 'ac',
                                content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试'
                            },
                            {
                                name: 'ad',
                                content: '测试测试测'
                            },
                            {
                                name: 'ae',
                                content: '测试测试测'
                            }
                        ]
                    }
                ]
            }
        ]
        renderOneLayer()
    </script>
</body>
</html>