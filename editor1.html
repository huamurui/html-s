<html>
<head>
  <meta charset="utf-8">
  <title>editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    #editor {
      position: relative;
      width: 500px;
      height: 500px;
      font-family: Consolas, "Courier New", monospace;
      /* font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace; */
      background-color: #eee;
      user-select: none;
      cursor: text;
      margin: 20px;
    }

    .view-lines {
      font-size: 14px;
    }
    
    .view-line {
      /* font-family: Consolas, "Courier New", monospace; */
      height: 19px;
    }

    /* 设置光标的样式 */
    .cursor {
      position: absolute;
      display: inline-block;
      width: 2px;
      height: 19px;
      top: 0;
      left: 0;
      background-color: black;
      animation: blink 1s infinite;
    }
    /* 设置光标的闪烁效果 */
    @keyframes blink {
      50% {
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="editor">
    <div class="view-lines"></div>
    <textarea style="display: none;"></textarea>
    <span class="cursor"></span>
  </div>
  <div class="view-line"><span style="background-color: red;">9999999999</span></div>
  <div class="view-line"><span style="background-color: red;">2</span></div>
  <div class="view-line"><span style="background-color: red;">f</span></div>
  <div class="view-line"><span style="background-color: red;">f</span></div>
  <div class="view-line"><span style="background-color: red;">&nbsp;</span></div>
  <script>
    let exampleDoc = "function add(a, b) {\n return a + b \n}"
    let lines = new Proxy(exampleDoc.split('\n'), {
      get(target, prop) {
        return target[prop]
      },
      set(target, prop, value) {
        target[prop] = value
        // renderDoc(target)
        return true
      }
    })

    // 行高固定19px, 字体为monospace, 字号14px时，一个字符宽度为7.7px,高度16.5px, 一个tab宽度为4个字符.... 总之, 字符位置和像素位置之间的转换关系是固定的, 可以通过这个关系来计算光标的位置
    // ...字体，在不同设备上，竟然...不一样...呃
    const editor = document.querySelector('#editor')
    const cursor = document.querySelector('.cursor')
    const content = document.querySelector('.view-lines')
    // 处理特殊符号如空格, 因为空格在html中是, 所以需要转换
    function renderDoc(lines) {
      content.innerHTML = ''
      for (let i = 0; i < lines.length; i++) {
        const line = document.createElement('div')
        line.className = 'view-line'
        line.innerHTML = lines[i].replace(/ /g, '&nbsp;').replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;')
                          .replace(/function/g, '<span style="color: blue;">function</span>')
                          .replace(/return/g, '<span style="color: purple;">return</span>')
                          .replace(/\(/g, '<span style="color: blue;">(</span>')
                          .replace(/\)/g, '<span style="color: blue;">)</span>')
        content.appendChild(line)
      }
    }
    renderDoc(lines)
    let pagination = {
      line: 0,
      column: 0
    }

    let position = {
      left: 0,
      top: 0
    }

    function updateCursor() {
      cursor.style.left = position.left + 'px'
      cursor.style.top = position.top + 'px'
    }

    function updatePosition() {
      const text = lines[pagination.line]
      text.length > pagination.column 
      ? position.left = pagination.column * 7.7
      : position.left = text.length * 7.7
      position.top = pagination.line * 19
      updateCursor()
    }

    function moveLeft() {
      if (pagination.column > 0) {
        pagination.column--
      } else if (pagination.line > 0) {
        pagination.line--
        pagination.column = lines[pagination.line].length
      }
      updatePosition()
    }
    
    function moveRight() {
      if (pagination.column < lines[pagination.line].length) {
        pagination.column++
      } else if (pagination.line < lines.length - 1) {
        pagination.line++
        pagination.column = 0
      }
      updatePosition()
    }

    function moveUp() {
      if (pagination.line > 0) {
        pagination.line--
      }
      updatePosition()
    }

    function moveDown() {
      if (pagination.line < lines.length - 1) {
        pagination.line++
      }
      updatePosition()
    }

    function insertText(text) {
      if(text === '\n') {
        const line = lines[pagination.line]
        const left = line.slice(0, pagination.column)
        const right = line.slice(pagination.column)
        lines[pagination.line] = left
        lines.splice(pagination.line + 1, 0, right)
        pagination.line++
        pagination.column = 0
        exampleDoc = lines.join('\n')
      } else {
        lines[pagination.line] = lines[pagination.line].slice(0, pagination.column) + text + lines[pagination.line].slice(pagination.column)
        exampleDoc = lines.join('\n')
        pagination.column++
      }
      renderDoc(exampleDoc.split('\n'))
      updatePosition()
    }

    function deleteText() {
      if (pagination.column > 0) {
        lines[pagination.line] = lines[pagination.line].slice(0, pagination.column - 1) + lines[pagination.line].slice(pagination.column)
        pagination.column--
      } else if (pagination.line > 0) {
        pagination.line--
        pagination.column = lines[pagination.line].length
        lines[pagination.line] = lines[pagination.line].slice(0, pagination.column) + lines[pagination.line + 1]
        lines.splice(pagination.line + 1, 1)
      }
      exampleDoc = lines.join('\n')
      renderDoc(exampleDoc.split('\n'))
      updatePosition()
    }

    function handleKeydown(event) {
      if (event.key === 'ArrowLeft') {
        moveLeft()
      } else if (event.key === 'ArrowRight') {
        moveRight()
      } else if (event.key === 'ArrowUp') {
        moveUp()
      } else if (event.key === 'ArrowDown') {
        moveDown()
      } else if (event.key === 'Backspace') {
        deleteText()
      } else if (event.key.length === 1) {
        insertText(event.key)
      } else if (event.key === 'Enter') {
        insertText('\n')
      }
    }

    document.addEventListener('keydown', handleKeydown)
    document.addEventListener('click', (e) => {
      // 根据点击的位置计算光标的位置，更新光标的位置，并且更新line和column
      const x = e.clientX - content.getBoundingClientRect().left
      const y = e.clientY - content.getBoundingClientRect().top
      const line = Math.floor(y / 19)
      if(!lines[line]) return
      const text = lines[line]
      const column = Math.floor(x / 7.7) > text.length ? text.length : Math.floor(x / 7.7)
      position.left = text.slice(0, column).length * 7.7
      position.top = line * 19
      pagination.line = line
      pagination.column = column
      // updateCursor()
      updatePosition()
    })
    document.addEventListener('touchstart', (e) => {
      // 只能通过textarea...input 这些来吗 ...呃啊
    })

  </script>
</body>
</html>
