<html>
  <head>
    <meta charset="utf-8" />
    <title>editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --line-height: 19px;
      }
      * {
        margin: 0;
        padding: 0;
      }
      #editor {
        position: relative;
        width: calc(100%-40px);
        height: 500px;
        font-family: Consolas, "Courier New", monospace;
        /* font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace; */
        background-color: #eee;
        user-select: none;
        cursor: text;
        margin: 20px;
      }

      .view-lines {
        font-size: 14px;
      }

      .view-line {
        /* font-family: Consolas, "Courier New", monospace; */
        height: var(--line-height);
      }
      textarea {
        position: absolute;
        top: 0;
        left: 0;
        width: 1px;
        height: 1px;
        opacity: 0;
      }

      /* 设置光标的样式 */
      .cursor {
        position: absolute;
        display: inline-block;
        width: 2px;
        height: var(--line-height);
        top: 0;
        left: 0;
        background-color: black;
        animation: blink 1s infinite;
      }
      /* 设置光标的闪烁效果 */
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div id="editor">
      <div class="view-lines"></div>
      <textarea></textarea>
      <span class="cursor"></span>
    </div>
    <script>
      let exampleDoc = "function add(a, b) {\n return a + b \n}"
      let lines = new Proxy(exampleDoc.split("\n"), {
        get(target, prop) {
          return target[prop]
        },
        set(target, prop, value) {
          target[prop] = value
          // renderDoc(target)
          return true
        },
      })

      // 行高固定19px, 字体为monospace, 字号14px时，一个字符宽度为charWidthpx,高度16.5px, 一个tab宽度为4个字符.... 总之, 字符位置和像素位置之间的转换关系是固定的, 可以通过这个关系来计算光标的位置
      // ...字体，在不同设备上，竟然...不一样...呃

      let charWidth = 7.7
      let charHeight = 16.5 // 19-16.5=2.5
      let lineHeight = 19

      function getCharWidth() {
        const span = document.createElement("span")
        span.innerHTML = "a"
        span.style.fontSize = "14px"
        span.style.fontFamily = 'Consolas, "Courier New", monospace'
        document.body.appendChild(span)
        charWidth = Number(span.getBoundingClientRect().width.toFixed(1))
        charHeight = Number(span.getBoundingClientRect().height.toFixed(1))
        lineHeight = Number(2.5 + charHeight).toFixed(1)
        document.documentElement.style.setProperty("--line-height", lineHeight + "px")
        document.body.removeChild(span)
      }
      getCharWidth()

      const editor = document.querySelector("#editor")
      const cursor = document.querySelector(".cursor")
      const textarea = document.querySelector("textarea")
      const content = document.querySelector(".view-lines")
      // 处理特殊符号如空格, 因为空格在html中是, 所以需要转换
      function renderDoc(lines) {
        content.innerHTML = ""
        for (let i = 0; i < lines.length; i++) {
          const line = document.createElement("div")
          line.className = "view-line"
          line.innerHTML = lines[i]
            .replace(/ /g, "&nbsp;")
            .replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;")
            .replace(/function/g, '<span style="color: blue;">function</span>')
            .replace(/return/g, '<span style="color: purple;">return</span>')
            .replace(/\(/g, '<span style="color: blue;">(</span>')
            .replace(/\)/g, '<span style="color: blue;">)</span>')
          content.appendChild(line)
        }
      }
      renderDoc(lines)
      let pagination = {
        line: 0,
        column: 0,
      }

      let position = {
        left: 0,
        top: 0,
      }

      function updateCursor() {
        cursor.style.left = position.left + "px"
        cursor.style.top = position.top + "px"
        textarea.style.left = position.left + "px"
        textarea.style.top = position.top + "px"
        textarea.focus()
      }

      function updatePosition() {
        const text = lines[pagination.line]
        text.length > pagination.column ? (position.left = pagination.column * charWidth) : (position.left = text.length * charWidth)
        position.top = pagination.line * lineHeight
        updateCursor()
      }

      function moveLeft() {
        if (pagination.column > 0) {
          pagination.column--
        } else if (pagination.line > 0) {
          pagination.line--
          pagination.column = lines[pagination.line].length
        }
        updatePosition()
      }

      function moveRight() {
        if (pagination.column < lines[pagination.line].length) {
          pagination.column++
        } else if (pagination.line < lines.length - 1) {
          pagination.line++
          pagination.column = 0
        }
        updatePosition()
      }

      function moveUp() {
        if (pagination.line > 0) {
          pagination.line--
        }
        updatePosition()
      }

      function moveDown() {
        if (pagination.line < lines.length - 1) {
          pagination.line++
        }
        updatePosition()
      }

      function insertText(text) {
        if (text === "\n") {
          const line = lines[pagination.line]
          const left = line.slice(0, pagination.column)
          const right = line.slice(pagination.column)
          lines[pagination.line] = left
          lines.splice(pagination.line + 1, 0, right)
          pagination.line++
          pagination.column = 0
          exampleDoc = lines.join("\n")
        } else {
          lines[pagination.line] = lines[pagination.line].slice(0, pagination.column) + text + lines[pagination.line].slice(pagination.column)
          exampleDoc = lines.join("\n")
          pagination.column++
        }
        renderDoc(exampleDoc.split("\n"))
        updatePosition()
      }

      function deleteText() {
        if (pagination.column > 0) {
          lines[pagination.line] = lines[pagination.line].slice(0, pagination.column - 1) + lines[pagination.line].slice(pagination.column)
          pagination.column--
        } else if (pagination.line > 0) {
          pagination.line--
          pagination.column = lines[pagination.line].length
          lines[pagination.line] = lines[pagination.line].slice(0, pagination.column) + lines[pagination.line + 1]
          lines.splice(pagination.line + 1, 1)
        }
        exampleDoc = lines.join("\n")
        renderDoc(exampleDoc.split("\n"))
        updatePosition()
      }

      function handleKeydown(event) {
        switch (event.key) {
          case "ArrowLeft":
            moveLeft()
            break
          case "ArrowRight":
            moveRight()
            break
          case "ArrowUp":
            moveUp()
            break
          case "ArrowDown":
            moveDown()
            break
          case "Backspace":
            deleteText()
            break
          case "Enter":
            insertText("\n")
            break
          default:
            if (event.key.length === 1) {
              insertText(event.key)
            }
        }
      }

      document.addEventListener("keydown", handleKeydown)
      document.addEventListener("click", (e) => {
        // 根据点击的位置计算光标的位置，更新光标的位置，并且更新line和column
        const x = e.clientX - content.getBoundingClientRect().left
        const y = e.clientY - content.getBoundingClientRect().top
        const line = Math.floor(y / lineHeight)
        if (!lines[line]) return
        const text = lines[line]
        const column = Math.floor(x / charWidth) > text.length ? text.length : Math.floor(x / charWidth)
        position.left = text.slice(0, column).length * charWidth
        position.top = line * lineHeight
        pagination.line = line
        pagination.column = column
        updatePosition()
      })
      if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
        textarea.addEventListener("input", (e) => {
          const text = e.target.value
          insertText(text)
          e.target.value = ""
        })
      }
    </script>
  </body>
</html>
