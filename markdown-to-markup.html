<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>reactivity & complier</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      height: 100vh;

      background-color: beige;
    }
    body > p {
      margin: 0px;
    }
    body > #playground {
      display: flex;
      flex-direction: row;
      margin: 0px 50px;
      height: 90%;
      background-color: aliceblue;
    }
    #playground > section {
      flex: 1;
      border: 1px solid rgb(232, 232, 232);
      overflow: hidden;
    }

    #playground > section > * {
      height: 100%;
      width: 100%;
      overflow: auto;
    }
    #playground > section > #markdown-editor {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    textarea {
      width: 100%;
      height: 100%;

      padding: 0;

      overflow: auto;

      border: none;
      outline: none;
      resize: none;
      background-color: aliceblue;
    }

    @media screen and (max-width: 600px) {
      body > #playground {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <p>a markdown editor and a markup preview and a toc, i am trying to learn reactive system and some compiler knowledge</p>
  <div id="playground">
    <section>
      <div id="markdown-editor">
        <!-- <label for="markdown">markdown editor</label> -->
        <textarea id="markdown"></textarea>
      </div>
    </section>

    <section>
      <div id="markup-preview">
      </div>
    </section>
  </div>

  <script>
/* 
[abc](https://abc)
  
**abc**
  
### abc
  
*/
    /* 
      may be single file is not enough ...
      ### i want to try out following things:
      
      1. meta programming, use Proxy, Reflect to create a reactive ui-data
      2. component based on hoc, hooks, and many other design patterns
      3. maybe some compiler(?

      ### and use them to create some interesting things
      a. pet, game, chatroom...
      b. homepage of your own
      c. ... the editor!
    */

    /* 
      i just found that ... the 'editor' alone is also a hard work... it couldn't be done by a simple textarea, if you want good style, or add some features like syntax highlight... even if you don't plan to do the compile part at all, you still need to know something about compiler, lexer, parser ... then hide the original textarea and replace it with styled html elements and bind the position of the cursor to the textarea and so on and so on...

      and there are also something like wysiwyg ...

      ### it's much more difficult than i thought to me, even just a demo... really...

      so, do the simple part, make clear how much you want to get... or go to see more code of others

      1. markdown to markup, pick up title, paragraph, link.
      1.1 make good style in the markdown editor, markup preview, toc make them scroll together highlight the title, link even in the editor

      2. data <=> ui, use Proxy, Reflect to create reactive data rather than a eventListener, and deal with dom render... also use proxy, to take care of diff.... is it necessary or doable? i mean... to do the diff while compiling? .... what are you thinking ???

      重新确认需求。
      你可能能做到的是，解析 markdown 部分语法，并在解析过程中具体而言应该是生成 ast 这一步进行 diff，根据 diff 结果更新 dom。
      你基本不可能做到的是——一个像样的编辑器: 这需要你对输入内容的区域也进行美化，分块，分块对于两区域同步滚动也很重要。 

    */

    /*
      editor's tech..
      1. in the browser: contenteditable -> body(editor).setAttribute('contenteditable', true), `Window.getSelection` and give some button to add some style. tata~ you got it!
      2. what i mentioned above, things like proxy the data and user actions, data driven...

      [https://juejin.cn/post/6844903504478208007]这是... 近六年前的一篇文章了，然而六年了这个 slateJS 还在 beta （233. 
      [https://zhuanlan.zhihu.com/p/268366406]
      还有一些历史...Quill.js 好像是我之前看到的那个写 redis 插件的人有参与...

      好像并没有什么收获...毕竟我一行代码都还没写。要考虑确认的...有点多，目前写的这个真的就只是糊了糊而已。也许对计算机的理解又多了一点。vue 或者 react 这样的框架给出的并不是性能或者单纯效率的提升，而是理念的变化，jQuery 写的政府官网和现代网站整个体验也都是不一样的。对于开发而言，免除了手动操作 dom 的劳役，解放的注意力可以做很多别的，数据驱动，组件化... “状态”...嗯，这是个很有意思的东西。

      理念。所以，学编程也一定要会键政(x

    */

    // set reactive data and get the dom and bind the data. once the data changed, the dom will be updated, rerender the markup preview and toc
    // by simple, maybe a eventListener is enough, but i want to ... make it(doms) rely on data rather than directly on user actions.
    const rules = {
      head: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      paragraph: /^[^\n]+/,
      bold: /\*\*([^*]+)\*\*/,
      link: /\[([^\]]+)\]\(([^)]+)\)/,
      list: /^\s*[-+*]\s+/,
      html: /^<(\w+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/,
      hr : /^( *[-*_]){3,} *(?:\n+|$)/,
    }
    const markdown = document.querySelector('#markdown')
    const markupPreview = document.querySelector('#markup-preview')
    const data = new Proxy(
      { 
        markdown: '',
        tokens: [],
        ast: [],
      }, 
      {
        set(target, key, value) {
          target[key] = value
          if(key === 'markdown') {
            markupPreview.innerHTML = render(parser(lexer(value)))            
          }
          return true
        }
      }
    )

    // init value
    data.markdown = document.querySelector('script').innerText
    markdown.value = data.markdown
    markdown.addEventListener('input', debounce(update, 500))
    function update(e) {
      data.markdown = e.target.value
    }

    // a simple tokenizer which can deal the head, paragraph, link and list, it take markdown as input and return tokens as output
    /* 
      目前的实现... 很有问题，首先你现在这破玩意的匹配必须另起一行并且前面不能带空格，链接匹配只要开始就不会中断如果缺了空格啥的会直接把全文都当成那啥...，另外它也不支持嵌套组合一类的，匹配到一种其他的就不能用了。还有一些必要的细节问题，比如到底改怎么看到空格和换行，什么时候inline什么时候block... 都压根没有考虑。怎么说... 这破玩意，是只在某些特殊时刻才会起作用的蛇皮代码...

      还有一件事，那你要在这里做到多少？直接识别出 tag，还是更精细简单一些的字符？然后别的交给后面的 parser？
      ... so bad bad bad
    */
    function lexer(markdown) {
      const tokens = []
      let cur = 0
      let len = markdown.length
      while(cur < len) {
        let char = markdown[cur]
        if(char === '#') {
          let match = markdown.slice(cur).match(rules.head)
          if(match) {
            tokens.push({
              type: 'head',
              content: match[0].slice(match[0].indexOf(' ') + 1),
              level: match[1].length        
            })
            cur += match[0].length
            continue
          }
        }
        else if(char === '*') {
          let match = markdown.slice(cur).match(rules.bold)
          if(match) {
            tokens.push({
              type: 'bold',
              content: match[1]
            })
            cur += match[0].length
            continue
          }
        }
        else if(char === '[') {
          let match = markdown.slice(cur).match(rules.link)
          if(match) {
            tokens.push({
              type: 'link',
              content: match[1],
              link: match[2]
            })
            cur += match[0].length
            continue
          }
        }
        else if(char === '-' || char === '+' || char === '*') {
          let match = markdown.slice(cur).match(rules.list)
          if(match) {
            tokens.push({
              type: 'list',
              content: match[0].slice(match[0].indexOf(' ') + 1)
            })
            cur += match[0].length
            continue
          }
        }
        else if(char === '<') {
          let match = markdown.slice(cur).match(rules.html)
          if(match) {
            tokens.push({
              type: 'html',
              content: match[0]
            })
            cur += match[0].length
            continue
          }
        }
        else if(char === '-') {
          let match = markdown.slice(cur).match(rules.hr)
          if(match) {
            tokens.push({
              type: 'hr',
              content: match[0]
            })
            cur += match[0].length
            continue
          }
        }
        else {
          let match = markdown.slice(cur).match(rules.paragraph)
          if(match) {
            tokens.push({
              type: 'paragraph',
              content: match[0]
            })
            cur += match[0].length
            continue
          }
        }
        cur++
      }

      return tokens
    }
    // it take tokens as input and return ast as output
    function parser(tokens) {
      const ast = []
      let cur = 0
      let len = tokens.length
      while(cur < len) {
        let token = tokens[cur]
        if(token.type === 'head') {
          ast.push({
            type: 'head',
            content: token.content,
            level: token.level
          })
        }
        else if(token.type === 'bold') {
          ast.push({
            type: 'bold',
            content: token.content
          })
        }
        else if(token.type === 'link') {
          ast.push({
            type: 'link',
            content: token.content,
            link: token.link
          })
        }
        else if(token.type === 'list') {
          ast.push({
            type: 'list',
            content: token.content
          })
        }
        else if(token.type === 'html') {
          ast.push({
            type: 'html',
            content: token.content
          })
        }
        else if(token.type === 'hr') {
          ast.push({
            type: 'hr',
            content: token.content
          })
        }
        else if(token.type === 'paragraph') {
          ast.push({
            type: 'paragraph',
            content: token.content
          })
        }
        cur++
      }
      

      return ast
    }

    function render(ast) {
      let html = ''
      ast.forEach(item => {
        if(item.type === 'head') {
          html += `<h${item.level}>${item.content}</h${item.level}>`
        }
        else if(item.type === 'bold') {
          html += `<strong>${item.content}</strong>`
        }
        else if(item.type === 'link') {
          html += `<a href="${item.link}">${item.content}</a>`
        }
        else if(item.type === 'list') {
          html += `<li>${item.content}</li>`
        }
        else if(item.type === 'html') {
          html += item.content
        }
        else if(item.type === 'hr') {
          html += `<hr />`
        }
        else if(item.type === 'paragraph') {
          html += `<p>${item.content}</p>`
        }
      })
      
      
      return html
    }

    const syncScroller = function () {
      let nodes = Array.prototype.filter.call(arguments, item => item instanceof HTMLElement)
      let max = nodes.length
      if (!max || max === 1) return
      let sign = 0 // 用于标注
      
      function event (e) {
        if (!sign) { // 标注为 0 时 表示滚动起源
          sign = max - 1
          let percent = this.scrollTop / (this.scrollHeight - this.clientHeight) // 计算源的滚动百分比
          for (node of nodes) { // 同步所有除自己以外节点
            if (node == this) continue
            node.scrollTop = percent * (node.scrollHeight - node.clientHeight)
          }
        } else
          -- sign // 其他节点滚动时 标注减一
      }
      
      nodes.forEach((ele, index) => {
          ele.addEventListener('scroll', event)
      })
      return () => {
        nodes.forEach((ele, index) => {
            ele.removeEventListener('scroll', event)
        })
      }
    }
    const syncS = syncScroller(markdown, markupPreview)
    // syncS() // 解绑

    /* 
      tools
    */

    function debounce(fn, delay) {
      let timer = null
      return function() {
        if(timer) clearTimeout(timer)
        timer = setTimeout(() => {
          fn.apply(this, arguments)
        }, delay)
      }
    }

    function throttle(fn, delay) {
      let timer = null
      return function() {
        if(timer) return
        timer = setTimeout(() => {
          fn.apply(this, arguments)
          timer = null
        }, delay)
      }
    }
  </script>
</body>
</html>

