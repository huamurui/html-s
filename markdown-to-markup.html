<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>reactivity & complier</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      height: 100vh;

      background-color: beige;
    }
    body > p {
      margin: 0px;
    }
    body > #playground {
      display: flex;
      flex-direction: row;
      margin: 0px 50px;
      height: 90%;
      background-color: aliceblue;
    }
    #playground > section {
      flex: 1;
      border: 1px solid rgb(232, 232, 232);
      overflow: hidden;
    }

    #playground > section > * {
      height: 100%;
      width: 100%;
      overflow: auto;
    }
    #playground > section > #markdown-editor {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    textarea {
      width: 100%;
      height: 100%;

      padding: 0;

      overflow: auto;

      border: none;
      outline: none;
      resize: none;
      background-color: aliceblue;
    }

    @media screen and (max-width: 600px) {
      body > #playground {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <p>a markdown editor and a markup preview and a toc, i am trying to learn reactive system and some compiler knowledge</p>
  <div id="playground">
    <section>
      <div id="markdown-editor">
        <textarea title="markdown" id="markdown"></textarea>
      </div>
    </section>

    <section>
      <div id="markup-preview">
      </div>
    </section>
  </div>

  <script>
    const testal = `
# h1
## h2
### h3
#### *h4*

**bold** __bold__

*italic* _italic_

\`code\`
<br><br>
i have tried many ... path. but considering the ability of mine, maybe the easiest way do it better, cause i... really do know how to handle them...

\`i have tried many ... path. but considering the ability of mine, maybe the easiest way do it better, cause i... really do know how to handle them...\`


\`我试了好多东西，踩坑吧，但就目前而言，现在这个最<ruby>简单<rt>ben dan</rt></ruby>的方法效果功能可能是最好的，因为那些玩意我是真搞不懂... 还不如直接硬写算球。 虽然这样好像... 学不到什么东西就是了。\`



### [link-baidu](https://www.baidu.com/)

![*image*](https://www.baidu.com/img/flexible/logo/pc/result.png)

- list
## - list

> blockquote
aaa
---

<em>html</em>


<button>html</button>


<textarea style="height:100px;width:200px;border: 1px solid black;" id="konorainbowda"></textarea>

oh...this is dangerous, but who cares?
`

    const rules = {
      regexp:{
        heading: /^(#{1,6})\s+(.+)$/gm,
        bold: /(\*\*|__)(.+?)\1/g,
        italic: /(\*|_)(.+?)\1/g,
        code: /(`+)(.+?)\1/g,
        // 这里的顺序，...其实应该也是优先级。如果那个循环是有序的话
        image: /!\[(.+?)\]\((.+?)\)/g,
        link: /\[(.+?)\]\((.+?)\)/g,
        list: /^(\*|\-|\+)\s+(.+)$/gm,
        blockquote: /^>\s+(.+)$/gm,
        hr: /^-{3,}$/gm,
        newline: /\n{2,}/g,

        html : /<[^>]+>/g,
      },
      replace:{
        heading: function (match, p1, p2) {
          var level = p1.length;
          return "<h" + level + ">" + p2 + "</h" + level + ">";
        },
        bold: function (match, p1, p2) {
          return "<strong>" + p2 + "</strong>";
        },
        italic: function (match, p1, p2) {
          return "<em>" + p2 + "</em>";
        },
        code: function (match, p1, p2) {
          return "<code>" + p2 + "</code>";
        },
        image: function (match, p1, p2) {
          return "<img src=\"" + p2 + "\" alt=\"" + p1 + "\">";
        },
        link: function (match, p1, p2) {
          return "<a href=\"" + p2 + "\">" + p1 + "</a>";
        },
        list: function (match, p1, p2) {
          return "<li>" + p2 + "</li>";
        },
        blockquote: function (match, p1) {
          return "<blockquote>" + p1 + "</blockquote>";
        },
        hr: function () {
          return "<hr>";
        },
        newline: function () {
          return "<br>";
        },

        html: function (match) {
          return match;
        },
      }
    }
    const markdown = document.querySelector('#markdown')
    const markupPreview = document.querySelector('#markup-preview')
    
    // let parserWithCache = AddCache(parser)
    const data = new Proxy(
      { 
        markdown: '',
        tokens: [],
        ast: [],
      }, 
      {
        set(target, key, value) {
          target[key] = value
          if(key === 'markdown') {
            // markupPreview.innerHTML = render(parser(lexer(value)))  
            // console.time('parser')
            markupPreview.innerHTML = parser(value)
            // markupPreview.innerHTML = parserWithCache(value)      
            // console.timeEnd('parser')
          }
          return true
        }
      }
    )

    // init value
    data.markdown = testal
    markdown.value = data.markdown
    markdown.addEventListener('input', debounce(update, 500))
    function update(e) {
      data.markdown = e.target.value
    }


    // function lexer(markdown) {
    //   const tokens = []
    // }
    // // it take tokens as input and return ast as output
    // function parser(tokens) {
    //   const ast = [] // 如果你以后要缓存的话..也许要用一下下“闭包”哦  
      
    //   return html
    // }
    
    function parser(markdown){
      let html = markdown
      for(let key in rules.regexp) {
        // 如果能把颗粒度再细一些就好了...现在是完全做不了缓存的...更不可能diff
        html = html.replace(rules.regexp[key], rules.replace[key])
      }
      return html
    }
    
    // function AddCache(fn) {
    //   let cache = {}
    //   return function (markdown) {
    //     if(cache[markdown]) return cache[markdown]
    //     let html = fn(markdown)
    //     cache[markdown] = html
    //     return html
    //   }
    // }


    /* 
      tools~~
    */
    const syncScroller = function () {
      let nodes = Array.prototype.filter.call(arguments, item => item instanceof HTMLElement)
      let max = nodes.length
      if (!max || max === 1) return
      let sign = 0 // 用于标注
      
      function event (e) {
        if (!sign) { // 标注为 0 时 表示滚动起源
          sign = max - 1
          let percent = this.scrollTop / (this.scrollHeight - this.clientHeight) // 计算源的滚动百分比
          for (node of nodes) { // 同步所有除自己以外节点
            if (node == this) continue
            node.scrollTop = percent * (node.scrollHeight - node.clientHeight)
          }
        } else
          -- sign // 其他节点滚动时 标注减一
      }
      
      nodes.forEach((ele, index) => {
          ele.addEventListener('scroll', event)
      })
      return () => {
        nodes.forEach((ele, index) => {
            ele.removeEventListener('scroll', event)
        })
      }
    }
    const syncS = syncScroller(markdown, markupPreview)
    // syncS() // 解绑

    function debounce(fn, delay) {
      let timer = null
      return function() {
        if(timer) clearTimeout(timer)
        timer = setTimeout(() => {
          fn.apply(this, arguments)
        }, delay)
      }
    }

    function throttle(fn, delay) {
      let timer = null
      return function() {
        if(timer) return
        timer = setTimeout(() => {
          fn.apply(this, arguments)
          timer = null
        }, delay)
      }
    }
  </script>
</body>
</html>

