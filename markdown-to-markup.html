<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>reactivity & complier</title>
  <style>

    body {
      margin: 0;
      padding: 0;
      height: 100vh;

      background-color: beige;
    }
    body > p {
      margin: 0px;
    }
    body > #playground {
      display: flex;
      flex-direction: row;
      margin: 0px 50px;
      height: 90%;
      background-color: aliceblue;
    }
    #playground > section {
      flex: 1;
      border: 1px solid rgb(232, 232, 232);
      overflow: hidden;
    }

    #playground > section > * {
      height: 100%;
      width: 100%;
      overflow: auto;
    }
    #playground > section > #markdown-editor {
      height: 100%;
      width: 100%;
      overflow: hidden;
    }

    textarea {
      width: 100%;
      height: 100%;

      overflow: auto;

      border: none;
      outline: none;
      resize: none;
      background-color: aliceblue;
    }

    @media screen and (max-width: 600px) {
      body > #playground {
        flex-direction: column;
      }
    }
      
    

  </style>
</head>
<body>
  <p>a markdown editor and a markup preview and a toc, i am trying to learn reactive system and some compiler knowledge</p>
  <div id="playground">
    <section>
      <div id="markdown-editor">
        <!-- <label for="markdown">markdown editor</label> -->
        <textarea id="markdown"></textarea>
      </div>
    </section>

    <section>
      <div id="markup-preview">
      </div>
    </section>
  </div>

  <script>

/* 
[abc](https://abc)
[abc]
## abc
### abc

**abc

*/
    /* 
      may be single file is not enough ...
      ### i want to try out following things:
      
      1. meta programming, use Proxy, Reflect to create a reactive ui-data
      2. component based on hoc, hooks, and many other design patterns
      3. maybe some compiler(?

      ### and use them to create some interesting things
      a. pet, game, chatroom...
      b. homepage of your own
      c. ... the editor!
    */

    /* 
      i just found that ... the 'editor' alone is also a hard work... it couldn't be done by a simple textarea, if you want good style, or add some features like syntax highlight... even if you don't plan to do the compile part at all, you still need to know something about compiler, lexer, parser ...; then hide the original textarea and replace it with styled html elements and bind the position of the cursor to the textarea and so on and so on...

      and there are also something like wysiwyg ...

      ### it's much more difficult than i thought to me, even just a demo... really...

      so, do the simple part, make clear how much you want to get... or go to see more code of others

      1. markdown to markup, pick up title, paragraph, link.
      1.1 make good style in the markdown editor, markup preview, toc; make them scroll together; highlight the title, link even in the editor;

      2. data <=> ui, use Proxy, Reflect to create reactive data rather than a eventListener, and deal with dom render... also use proxy, to take care of diff.... is it necessary or doable? i mean... to do the diff while compiling? .... what are you thinking ???

      重新确认需求。
      你可能能做到的是，解析 markdown 部分语法，并在解析过程中具体而言应该是生成 ast 这一步进行 diff，根据 diff 结果更新 dom。
      你基本不可能做到的是——一个像样的编辑器: 这需要你对输入内容的区域也进行美化，分块，分块对于两区域同步滚动也很重要。 

    */

    /*
      editor's tech..
      1. in the browser: contenteditable -> body(editor).setAttribute('contenteditable', true), `Window.getSelection` and give some button to add some style. tata~ you got it!
      2. what i mentioned above, things like proxy the data and user actions, data driven...

      [https://juejin.cn/post/6844903504478208007]这是... 近六年前的一篇文章了，然而六年了这个 slateJS 还在 beta （233. 
      [https://zhuanlan.zhihu.com/p/268366406]
      还有一些历史...Quill.js 好像是我之前看到的那个写 redis 插件的人有参与...

      好像并没有什么收获...毕竟我一行代码都还没写。要考虑确认的...有点多，目前写的这个真的就只是糊了糊而已。也许对计算机的理解又多了一点。vue 或者 react 这样的框架给出的并不是性能或者单纯效率的提升，而是理念的变化，jQuery 写的政府官网和现代网站整个体验也都是不一样的。对于开发而言，免除了手动操作 dom 的劳役，解放的注意力可以做很多别的，数据驱动，组件化... “状态”...嗯，这是个很有意思的东西。

      理念。所以，学编程也一定要会键政(x

    */

    // set reactive data and get the dom and bind the data. once the data changed, the dom will be updated, rerender the markup preview and toc
    // by simple, maybe a eventListener is enough, but i want to ... make it(doms) rely on data rather than directly on user actions.
    const markdown = document.querySelector('#markdown')
    const markupPreview = document.querySelector('#markup-preview')
    const data = new Proxy(
      { 
        markdown: '',
        tokens: [],
        ast: [],
      }, 
      {
        set(target, key, value) {
          target[key] = value
          if(key === 'markdown') {

            markupPreview.innerHTML = render(parser(tokenizer(value, value.length)))            
          }
          return true
        }
      }
    )

    // init value
    data.markdown = document.querySelector('script').innerText

    markdown.value = data.markdown
    
    markdown.addEventListener('input', e => {
      data.markdown = e.target.value
    })



    // a simple tokenizer which can deal the head, paragraph, link and list, it take markdown as input and return tokens as output
    function tokenizer(markdown, length){
      let thisMarkdown = markdown
      const tokens = []
      let i = 0
      while(i < length) {
        if(thisMarkdown[i] === '#') {
          let j = i + 1
          while(thisMarkdown[j] === '#') j++
          const token = {
            type: 'head',
            level: j - i,
            content: thisMarkdown.slice(j).split('\n')[0]
          }
          tokens.push(token)
          i = j + token.content.length
        } 
        else if(thisMarkdown[i] === '*') {
          let j = i + 1
          while(thisMarkdown[j] === '*') j++
          const token = {
            type: 'list',
            level: j - i,
            content: thisMarkdown.slice(j).split('\n')[0]
          }
          tokens.push(token)
          i = j + token.content.length
        } 
        else if(thisMarkdown[i] === '[') { // start the link
          // i-j is the content of the link, j-k is the link, the link should be in one line, and () is optional, the signal [] have same content and link
          let j = i + 1
          while(thisMarkdown[j] !== ']') j++
          let k = j + 1
          if(thisMarkdown[k] === '(') {
            k++
            while(thisMarkdown[k] !== ')') k++
          }
          const token = {
            type: 'link',
            content: thisMarkdown.slice(i + 1, j),
            link: k - j === 1 ? thisMarkdown.slice(i + 1, j) : thisMarkdown.slice(j + 1, k)
          }
          tokens.push(token)
          i = k + 1
        }
        else {
          const token = {
            type: 'paragraph',
            content: thisMarkdown.slice(i).split('\n')[0]
          }
          tokens.push(token)
          i += token.content.length + 1
        }
      }
      return tokens
   
    }
    
    // it take tokens as input and return ast as output
    function parser(tokens) {
      const ast = []
      let i = 0
      while(i < tokens.length) {
        if(tokens[i].type === 'head') {
          const head = {
            type: 'head',
            level: tokens[i].level,
            content: tokens[i].content,
            children: []
          }
          ast.push(head)
          i++
        }
        else if(tokens[i].type === 'list') {
          const list = {
            type: 'list',
            level: tokens[i].level,
            content: tokens[i].content,
            children: []
          }
          ast.push(list)
          i++
        }
        else if(tokens[i].type === 'link') {
          const link = {
            type: 'link',
            content: tokens[i].content,
            link: tokens[i].link
          }
          ast.push(link)
          i++
        }
        else if(tokens[i].type === 'paragraph') {
          const paragraph = {
            type: 'paragraph',
            content: tokens[i].content
          }
          ast.push(paragraph)
          i++
        }
      }
      console.log(ast)
      return ast
    }

    function render(ast) {
      let html = ''
      ast.forEach(node => {
        if(node.type === 'head') {
          html += `<h${node.level}>${node.content}</h${node.level}>`
        }
        else if(node.type === 'list') {
          html += `<li>${node.content}</li>`
        }
        else if(node.type === 'link') {
          html += `<a href="${node.link}">${node.content}</a>`
        }
        else if(node.type === 'paragraph') {
          html += `<p>${node.content}</p>`
        }
      })
      return html
    }

    // make two parts scroll together : markdown and markupPreview
    let scrolling = 0  // 0: none; 1: 编辑区主动触发滚动; 2: 展示区主动触发滚动
    let scrollTimer = null // 
    markdown.addEventListener('scroll', function(e,block=1){
      // 这样可以传参，然而这样... 匿名函数无法移除了
      handleScroll(e,block)
    })
    markupPreview.addEventListener('scroll', function(e,block=2){
      handleScroll(e,block)
    })

    function handleScroll (e,block) {
      const { scrollTop, scrollHeight, clientHeight } = e.target
      const percent = scrollTop / (scrollHeight - clientHeight)
      if(block === 1) {
        if(scrolling === 0) scrolling = 1
        if(scrolling === 2) return

      }
      else if(block === 2) {
        if(scrolling === 0) scrolling = 2
        if(scrolling === 1) return
      }
      scroll(percent, block === 1 ? markupPreview : markdown)
      
      if(scrollTimer) clearTimeout(scrollTimer)
      scrollTimer = setTimeout(() => {
        scrolling = 0
      }, 100)

    }

    function scroll(percent, el) {
      const { scrollHeight, clientHeight } = el
      el.scrollTop = (scrollHeight - clientHeight) * percent
    } 
  </script>
</body>
</html>

