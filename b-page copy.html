<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>b page</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        #playground {
            width: 100vw;
            height: 100vh;
            font-size: 16px;
            font-family:'Hiragino Sans GB','STXihei';
            color: #372d52;
        }

        .menu__column {
            position: fixed;
            display: flex;
            flex-direction: column;
            width: 200px;
            box-shadow: 
                2px 1px 1px #a7783d, 
                -1px -1px 1px #fff;
            background-color: antiquewhite;
            border-radius: 4px;
        }
        .menu__item {
            display: flex;
            margin: 2px;
            padding: 2px 6px 2px 6px;
            justify-content: space-between;
        }
        .menu__item--on-path,
        .menu__item:hover {
            border-radius: 8px;
            background-color:aliceblue;
            /* color: #fff; */
        }
        .menu__icon {
            width: 16px;
            height: 16px;
            /* color: #000; */
            font-weight: bolder;
        }
    </style>
</head>
<body>
    <div id="playground"></div>
    <script>
        let position = {
            x: 0,
            y: 0
        }
        let preDirection = {
            x: 'right',
            y: 'bottom'
        }
        let direction = new Proxy(
            {
                x: 'right',
                y: 'bottom'
            }, 
            {
                set (target, key, value) {
                    // 新旧不同时，旧值给到 preDirection
                    if (target[key] !== value) {
                        preDirection[key] = target[key]
                        target[key] = value
                    }
                }
            }
        )
        let adjustXY = {
            x: 0, 
            y: 0
        }
        // 新添加的栏，要在哪个方向上新增
        function getAppendDirection(position=position, size={ width: 200, height: 0}) {
            const { x, y } = position
            const { innerWidth, innerHeight } = window
            const { width, height } = size
            if (x + width > innerWidth) { direction.x = 'left' }
            if (y + height > innerHeight) { direction.y = 'top'}
            if (x - width < 0) { direction.x = 'right'}
            if (y - height < 0) { direction.y = 'bottom'}
            const directionstr = `${direction.x}-${direction.y}`
            return directionstr
        }
        function operateAdjustXY(adjustXY, direction) {
            switch (direction) {
                case 'right-bottom':
                    adjustXY.x = 190
                    adjustXY.y = 21
                    break
                case 'left-bottom':
                    adjustXY.x = -190
                    adjustXY.y = 21
                    break
                case 'right-top':
                    adjustXY.x = 190
                    adjustXY.y = -21
                    break
                case 'left-top':
                    adjustXY.x = -190
                    adjustXY.y = -21
                    break
                default:
                    break
            }
        }

        // 鼠标移出一个栏时，是从哪个方向移出的
        // 此处废弃。
        // 我们需要实现的是... 不看方向的版本


        /**
         * 嗯...不对，应该首先考虑，有两种东西。一个是，一个栏，一个是，一个栏里面的条目
         * 可监听的事件就是移入移出。并且我们有这些文本的类似 parent-child 的关系
         * 我们的 hover 事件，肯定是要精准到条目的
         * 进而，继续理
         * 
         * 当 hover 到一个条目时，如果有子元素，就渲染子元素，没有的话...就不渲染这不废话...
         * 当 hover 离开一个条目时...
         * 
         * 细分。先看 a，状态以及可能的转移
         * a.1 
         * 当前没有 hover 到任何条目上位于空白，将要 hover 到某个条目
         * a.2
         * 当前 hover 到了某一个条目，将要离开这个条目
         * a.2.1
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了其子元素
         * a.2.2
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了其父元素
         * a.2.3
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了空白
         * a.2.4
         * 当前 hover 到了某一个条目，将要离开这个条目，进入了兄弟元素
         * 
         * 然后是处理办法
         * b.1
         * hover 到某个条目，高亮，若数据结构里有子元素，渲染其子元素
         * b.2.1
         * hover 离开某个条目，高亮消失，进入其子元素，高亮，重复 a.2
         * b.2.2
         * hover 离开某个条目，高亮消失，进入其父一级的栏，取消本层的渲染，重复 a.2
         * b.2.3
         * hover 离开某个条目，进入空白，高亮消失，不做处理
         * b.2.4
         * hover 离开某个条目，进入兄弟元素，高亮消失，若此时本条目子元素已渲染，取消渲染，重复 a.2
         * 
         * 如何更合理的处理这个问题？
         * 
         * 如何判断是进入了子元素，还是父元素，还是兄弟元素，还是空白？
         * 每当进入某一层的时候，记录层数，这是一个全局变量，维护表示的是当前层数。
         * 而每一个栏，都有固定的一个数字。
         * 对于空白，给-1.
         * 
         * 每一次"进入"，都会改变这个层数，同时也可以计算出一个差值，这个差值，有可能是0，1，-1.甚至更大一些的数字。
         * 但是无所谓，我觉得有正负和零就够了。原来...这就是进入
         * 那"离开"是什么？
         * 也许根本就不需要有离开这个概念，只需要有进入这个概念就够了。
         * 
         * wow...这个思路真棒
         * 而且数据命名如果规范的话，一切都可以很方便
         * const getStep = (string1,string2) => string1.length - string2.length
         * 
         * 然后也许需要看看树的遍历，一个是看现在渲染了多少是什么状态，又进行了什么操作，以及下一步要做什么
         * 整个过程...也许可以更依赖数据结构一点
         * 
         */


        /**
         * 也许...我不应该这么丧...
         * 也许...我现在确实无聊又窘迫..
         * 我应该做什么？
         * 
         * 去学习痛苦吗...
         * 学校，父母...也只是那样...一开始是哄骗试探，慢慢威胁恐吓，最后是解离一般将自己看作个干脏活的...
         * 那些东西都太...
         * 如何原谅别人？去变强就好了，人不会向着一个被踩死的蚂蚁去寻求原谅，蚂蚁也没资格去原谅别人，这么干的有一个算一个都是神经病，但是如果踩的是老虎尾巴那就有寻求原谅的必要了。所以，去变强，纯粹的变强，这样就可以原谅了。“告诉我，我拿什么原谅你？我有什么资格原谅你？我有什么手段能把你也弄得半死不活？”
         * 
         * 学习痛苦与耻辱...
         * 像新生的婴儿那样...
         * 像...小时候那样...
         * 
         * 我一遍遍问的，究竟什么才算是值得的，我到底应该干什么？
         * 中学说是好好考试就好，即使不论把精力全投进那种考试中然后今天到这样算不算值得，
         * 中学里根本就不纯粹，初中喜欢捞便宜占搞补课班的班主任，高中因为我留头发一直吵，
         * 里面夹杂了太多乱七八糟的事，父母的懦弱、大惊小怪，学校以及所谓的“社会”的恐吓，
         * 就算我想当机器也当不好。
         * 所以，告诉我，这一切都是为了什么？
         * 
         * 到现在学历没再那么万能，就行它本来就屁用没有一样，
         * 想要的东西，尊重也好力量也好，哪怕是知识，学历都换不来，背书、等待也换不来...
         * 也许...我不应该这么丧...痛苦会在...仇恨会在...
         * 它们是生出你的东西，只是不要...把它们当作，全部。
         * 
         * 我是小狗吗？
         * 我是笨蛋吗
         * 我应该，去做点什么，
         * 就算，我只是，来旅游的。
         * 
         */

        function deepClone (obj) {
            return JSON.parse(JSON.stringify(obj))
        }
        // 重新思考一下，渲染依旧是要打平的不然叠压没法处理。
        // 渲染出的 dom 在 html 结构上是平的，但不意味着我们不能把它在 js 层上放到结构化数据里 or 在 js 这里保存一个引用。

        /**
         * 在此基础上，结合上面的。
         * 我们有三种鼠标移动的情况 -1 0 1
         * renderOneLayer 这个函数也肯定是要的。
         */

        let layer = -1
        function renderOneLayer (name='0', root=playground) {
            const thisPosition = position
            const selfData = getNode(name, article) || article[0]

            if (!selfData) return
            if (!selfData.children) return
            const selfEle = document.createElement('div')
            selfEle.innerHTML = `
                <div class="menu__column" data-name="${name}" style="left: ${thisPosition.x}px;top: ${thisPosition.y}px;">
                    ${selfData.children.map(child => `<div class="menu__item" data-name=${child.name}>${child.content + (child.children ? '<div class="menu__icon">></div>' : '')}</div>`).join('')}
                </div>
            `
            root.appendChild(selfEle)
            const items = selfEle.querySelectorAll('.menu__item')
            
            // get position
            operateAdjustXY(adjustXY, getAppendDirection(thisPosition, { width: 200, height: 0 }))
            position.x += adjustXY.x

            // 这一层里面只能有一条
            let plannedParenthood = false
            // recursively
            items.forEach((item, index) => {
                const name = item.getAttribute('data-name')
                const data = getNode(name, article)
                if(!data.children)  return

                // layer 这个变量什么时候更新合适？
                item.addEventListener('mouseenter', function (e) {
                    let thisLayer =  e.target.getAttribute('data-name').length
                    position.x = e.target.getClientRects()[0].left + adjustXY.x
                    position.y = item.getBoundingClientRect().top + adjustXY.y

                    if(layer - thisLayer === 0) {
                        // 兄弟
                        // 1. 清除兄弟的子的渲染，而且也是要递归式清除
                        const siblings = getSiblings(e.target.getAttribute('data-name'), article).filter(sibling => sibling.name !== e.target.getAttribute('data-name'))
                        const children = siblings.map(sibling => getChildren(sibling.name, article)).flat()
                        siblings.concat(children).forEach(child => {
                            // menu__column 和 data-name 
                            const columnEles = document.querySelectorAll('.menu__column')
                            // const childEle = document.querySelector(`[data-name="${child.name}"]`)
                            const childEle = [...columnEles].find(ele => ele.getAttribute('data-name') === child.name)
                            console.log('childEle', childEle, child.name, columnEles)
                            if (childEle) {
                                // 这玩意... 还是好多坑。回退的时候，位置判断也是个问题。尤其连着退的时候，之前改过方向的话，就会出现问题。
                                // 我是说，为什么，不能直接拿到这个元素的位置，然后直接减去它的高度，然后再减去200，就是新的位置了呢？
                                position.y -= childEle.getClientRects()[0].height
                                position.x -= 200
                                childEle.remove()
                            }
                        })

                        // 2. 渲染自己的子
                        renderOneLayer(e.target.getAttribute('data-name'))
                    }
                    if(layer - thisLayer > 0) {
                        // 父
                        // 1. 清除子的渲染...不，要清除的是递归式清除
                        const children = getChildren(e.target.getAttribute('data-name'), article)
                        // const children = data.children
                        children.forEach(child => {
                            const childEle = document.querySelector(`[data-name="${child.name}"]`)
                            if (childEle) {
                                position.y -= childEle.getClientRects()[0].height
                                position.x -= 200
                                childEle.remove()
                            }
                        })

                        // 2. 渲染自己的子
                        renderOneLayer(e.target.getAttribute('data-name'))
                    }
                    if(layer - thisLayer < 0) {
                        // 子。。？
                        // 这怎么做到呢...虽然有点奇怪但是应该也可以。
                        renderOneLayer(e.target.getAttribute('data-name'))
                    }
                    layer = thisLayer
                })

            })  
        }

        function getNode (name, article) {
            let node = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    node = article[i]
                    break
                } else if (article[i].children) {
                    node = getNode(name, article[i].children)
                    if (node) {
                        break
                    }
                }
            }
            return node
        }

        function getSiblings(name,article) {
            let parent = null
            for (let i = 0; i < article.length; i++) {
                if (article[i].name === name) {
                    parent = article
                    break
                } else if (article[i].children) {
                    parent = getSiblings(name, article[i].children)
                    if (parent) {
                        break
                    }
                }
            }
            return parent
        }

        function getChildren(name,article) {
            let children = []
            getNode(name, article)?.children?.forEach(child => {
                children.push(child)
                if (child.children) {
                    children = children.concat(getChildren(child.name, article))
                }
            })
            return children
        }

        const playground = document.getElementById('playground')
        const background = document.getElementById('background')
        const article = [
            {
                name:'',
                content:'0',
                children:[
                    {
                        name:'a',
                        content: '内库烧为锦绣灰，',
                        children: [
                            {
                                name: 'aa',
                                content: '天街踏尽公卿骨。',
                                children: [
                                    {
                                        name: 'aaa',
                                        content: '待到秋来九月八'
                                    },
                                    {
                                        name: 'aab',
                                        content: '我花开后百花杀'
                                    },
                                    {
                                        name: 'aac',
                                        content: '冲天香阵透长安',
                                    },
                                    {
                                        name: 'aad',
                                        content: '满城尽带黄金甲',
                                        children: [
                                            {
                                                name: 'aada',
                                                content: '红旗卷起农奴戟',
                                                children: [
                                                    {
                                                        name: 'aadaa',
                                                        content: '黑手高悬霸主鞭',
                                                        children: [
                                                            {
                                                                name: 'aadaaa',
                                                                content: '为有牺牲多壮志',
                                                                children: [
                                                                    {
                                                                        name: 'aadaaaa',
                                                                        content: '敢教日月换新天'
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                name: 'ab',
                                content: '陈王昔时宴平乐',
                                children: [
                                    {
                                        name: 'aba',
                                        content: '陈王奋起挥黄钺',
                                        children: [
                                            {
                                                name: 'abaa',
                                                content: '阿巴阿巴'
                                            }
                                        ]
                                    },
                                    {
                                        name: 'abb',
                                        content: '阿巴巴'
                                    }
                                ]
                            },
                            {
                                name: 'ac',
                                content: '测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试'
                            },
                            {
                                name: 'ad',
                                content: '测试测试测'
                            },
                            {
                                name: 'ae',
                                content: '测试测试测'
                            }
                        ]
                    }
                ]
            }
        ]
        function init() {
            const start = document.createElement('div')
            start.innerHTML = `
                <div class="menu__column" data-name="start00000000" style="left: 0px;top: 0px;">
                    <div class="menu__item" data-name="0">Start~<div class="menu__icon">></div></div>
                </div>
            `
            start.addEventListener('click',(e)=>{
                position.x = 200
                position.y = 21
                renderOneLayer('0')
            })
            playground.appendChild(start)
            document.addEventListener('click', (e) => {
                if(e.target === playground){
                    console.log('playground')
                    document.querySelectorAll('.menu__column').forEach(ele => {
                        if(ele.getAttribute('data-name') !== 'start00000000') {
                            ele.remove()
                        }
                    })
                }
            })
        
        }
        init()
    </script>
</body>
</html>